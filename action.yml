name: "Hiero Solo Action"
description: "Run a Hiero-based network using the solo tool"
inputs:
  installMirrorNode:
    description: "Defines if a mirror node should be installed"
    required: true
    default: false
    type: boolean
  hieroVersion:
    description: "Version of Hiero consensus node to use"
    required: false
    default: "v0.58.10"
  mirrorNodePortRest:
    description: "Port for Mirror Node REST API"
    required: false
    default: "8080"
  mirrorNodePortGrpc:
    description: "Port for Mirror Node gRPC"
    required: false
    default: "5600"
  installRelay:
    description: "Install JSON-RPC-Relay"
    required: false
    default: false
    type: boolean
  relayPort:
    description: "Port for JSON-RPC-Relay"
    required: false
    default: "7546"
  email:
    description: "Email for deployment configuration (optional)"
    required: false
    default: "user@example.com"
outputs:
  accountId:
    description: "Account ID of the generated ED25519 account"
    value: ${{ steps.create-ed25519.outputs.accountId }}
  publicKey:
    description: "Public key of the generated ED25519 account"
    value: ${{ steps.create-ed25519.outputs.publicKey }}
  privateKey:
    description: "Private key of the generated ED25519 account"
    value: ${{ steps.create-ed25519.outputs.privateKey }}
  ecdsaAccountId:
    description: "ECDSA account ID of generated account"
    value: ${{ steps.create-ecdsa.outputs.accountId }}
  ecdsaPublicKey:
    description: "ECDSA public key of generated account"
    value: ${{ steps.create-ecdsa.outputs.publicKey }}
  ecdsaPrivateKey:
    description: "ECDSA private key of generated account"
    value: ${{ steps.create-ecdsa.outputs.privateKey }}
  ed25519AccountId:
    description: "ED25519 account ID of generated account"
    value: ${{ steps.create-ed25519.outputs.accountId }}
  ed25519PublicKey:
    description: "ED25519 public key of generated account"
    value: ${{ steps.create-ed25519.outputs.publicKey }}
  ed25519PrivateKey:
    description: "ED25519 private key of generated account"
    value: ${{ steps.create-ed25519.outputs.privateKey }}
runs:
  using: "composite"
  steps:
    - name: Print inputs
      shell: bash
      run: |
        echo "installMirrorNode: ${{ inputs.installMirrorNode }}"
        echo "is installMirrorNode: ${{ inputs.installMirrorNode == 'true' }}"

    - name: Setup Java
      uses: actions/setup-java@99b8673ff64fbf99d8d325f52d9a5bdedb8483e9 # v4.2.1
      with:
        distribution: temurin
        java-version: 21

    - name: Setup Node
      uses: actions/setup-node@1e60f620b9541d16bece96c5465dc8ee9832be0b # v4.0.3
      with:
        node-version: 22

    - name: Install WGet CLI
      shell: bash
      run: sudo apt-get update && sudo apt-get install -y wget

    - name: Install Python
      uses: actions/setup-python@v5
      with:
        python-version: "3.10"

    - name: Setup Kind
      uses: helm/kind-action@0025e74a8c7512023d06dc019c617aa3cf561fde # v1.10.0
      with:
        version: v0.21.0
        kubectl_version: v1.28.6
        cluster_name: solo-e2e
        wait: 120s

    - name: Install Solo
      shell: bash
      run: npm install -g @hashgraph/solo@0.36.0
      # Consider upgrading to @hashgraph/solo@latest after testing:
      # run: npm install -g @hashgraph/solo@latest

    - name: Deploy Solo Test Network
      shell: bash
      env:
        SOLO_CLUSTER_NAME: solo-e2e
        SOLO_NAMESPACE: solo
        SOLO_CLUSTER_SETUP_NAMESPACE: solo-cluster
        SOLO_DEPLOYMENT: solo-deployment
        HIERO_VERSION: ${{ inputs.hieroVersion }}
      run: |
        # Create namespaces
        kubectl create namespace $SOLO_NAMESPACE --dry-run=client -o yaml | kubectl apply -f -
        kubectl create namespace $SOLO_CLUSTER_SETUP_NAMESPACE --dry-run=client -o yaml | kubectl apply -f -

        # Initialize solo
        solo init

        # Setup cluster
        echo "Running solo cluster-ref setup..."
        solo cluster-ref setup -s $SOLO_CLUSTER_SETUP_NAMESPACE --cluster-ref $SOLO_CLUSTER_NAME > cluster_setup_output.txt 2>&1
        cat cluster_setup_output.txt

        # Debug: Check for solo-remote-config ConfigMap in both namespaces
        echo "Checking for solo-remote-config ConfigMap in namespace $SOLO_NAMESPACE:"
        kubectl get configmap solo-remote-config -n $SOLO_NAMESPACE || echo "ConfigMap solo-remote-config not found in $SOLO_NAMESPACE"
        echo "Checking for solo-remote-config ConfigMap in namespace $SOLO_CLUSTER_SETUP_NAMESPACE:"
        kubectl get configmap solo-remote-config -n $SOLO_CLUSTER_SETUP_NAMESPACE || echo "ConfigMap solo-remote-config not found in $SOLO_CLUSTER_SETUP_NAMESPACE"

        # Debug: List all ConfigMaps in both namespaces
        echo "Listing all ConfigMaps in namespace $SOLO_NAMESPACE:"
        kubectl get configmap -n $SOLO_NAMESPACE
        echo "Listing all ConfigMaps in namespace $SOLO_CLUSTER_SETUP_NAMESPACE:"
        kubectl get configmap -n $SOLO_CLUSTER_SETUP_NAMESPACE

        # Create deployment
        solo deployment create --deployment $SOLO_DEPLOYMENT -n $SOLO_NAMESPACE --quiet-mode --cluster-ref $SOLO_CLUSTER_NAME > deployment_create_output.txt 2>&1
        cat deployment_create_output.txt

        # Generate node keys
        solo node keys --gossip-keys --tls-keys --node-aliases node1 --deployment $SOLO_DEPLOYMENT -n $SOLO_NAMESPACE > node_keys_output.txt 2>&1
        cat node_keys_output.txt

        # Deploy network
        solo network deploy --node-aliases node1 -d $SOLO_DEPLOYMENT -n $SOLO_NAMESPACE > network_deploy_output.txt 2>&1
        cat network_deploy_output.txt

        # Setup node
        solo node setup --node-aliases node1 --deployment $SOLO_DEPLOYMENT -n $SOLO_NAMESPACE -t $HIERO_VERSION --quiet-mode > node_setup_output.txt 2>&1
        cat node_setup_output.txt

        # Start node
        solo node start --node-aliases node1 --deployment $SOLO_DEPLOYMENT -n $SOLO_NAMESPACE > node_start_output.txt 2>&1
        cat node_start_output.txt

        # Debug: List deployments
        echo "Listing deployments:"
        solo deployment list --cluster-ref $SOLO_CLUSTER_NAME > deployment_list_output.txt 2>&1
        cat deployment_list_output.txt

        # Debug: List services in the solo namespace
        echo "Listing services in namespace $SOLO_NAMESPACE:"
        kubectl get svc -n $SOLO_NAMESPACE

        # Port forward HAProxy (only if service exists)
        if kubectl get svc haproxy-node1-svc -n $SOLO_NAMESPACE >/dev/null 2>&1; then
          kubectl port-forward svc/haproxy-node1-svc -n $SOLO_NAMESPACE 50211:50211 &
        else
          echo "HAProxy service haproxy-node1-svc not found, skipping port-forward"
        fi

    - name: Deploy MirrorNode
      if: ${{ inputs.installMirrorNode == 'true' }}
      shell: bash
      env:
        SOLO_NAMESPACE: solo
        SOLO_DEPLOYMENT: solo-deployment
      run: |
        solo mirror-node deploy --deployment $SOLO_DEPLOYMENT -n $SOLO_NAMESPACE
        # Debug: List services in the solo namespace
        echo "Listing services in namespace $SOLO_NAMESPACE:"
        kubectl get svc -n $SOLO_NAMESPACE
        # Port forward mirror node REST API (only if service exists)
        if kubectl get svc mirror-rest -n $SOLO_NAMESPACE >/dev/null 2>&1; then
          kubectl port-forward svc/mirror-rest -n $SOLO_NAMESPACE ${{ inputs.mirrorNodePortRest }}:80 &
        else
          echo "Mirror node service mirror-rest not found, skipping port-forward"
        fi
        # Port forward mirror node gRPC (only if service exists)
        if kubectl get svc mirror-grpc -n $SOLO_NAMESPACE >/dev/null 2>&1; then
          kubectl port-forward svc/mirror-grpc -n $SOLO_NAMESPACE ${{ inputs.mirrorNodePortGrpc }}:5600 &
        else
          echo "Mirror node service mirror-grpc not found, skipping port-forward"
        fi

    - name: Deploy JSON-RPC-Relay
      if: ${{ inputs.installRelay == 'true' }}
      shell: bash
      env:
        SOLO_NAMESPACE: solo
        SOLO_DEPLOYMENT: solo-deployment
      run: |
        echo "Installing JSON-RPC-Relay..."
        solo relay deploy --node-aliases node1 --deployment $SOLO_DEPLOYMENT -n $SOLO_NAMESPACE
        echo "JSON-RPC-Relay installed successfully"
        # Debug: List services in the solo namespace
        echo "Listing services in namespace $SOLO_NAMESPACE:"
        kubectl get svc -n $SOLO_NAMESPACE
        # Port forward JSON-RPC-Relay (only if service exists)
        if kubectl get svc relay-node1-hedera-json-rpc-relay -n $SOLO_NAMESPACE >/dev/null 2>&1; then
          kubectl port-forward svc/relay-node1-hedera-json-rpc-relay -n $SOLO_NAMESPACE ${{ inputs.relayPort }}:7546 &
        else
          echo "JSON-RPC-Relay service relay-node1-hedera-json-rpc-relay not found, skipping port-forward"
        fi

    - name: Create ECDSA Account
      id: create-ecdsa
      shell: bash
      env:
        GITHUB_ACTION_PATH: ${{ github.action_path }}
        SOLO_NAMESPACE: solo
        SOLO_DEPLOYMENT: solo-deployment
      run: |
        echo "Creating ECDSA account..."
        solo account create --generate-ecdsa-key --deployment $SOLO_DEPLOYMENT -n $SOLO_NAMESPACE > account_create_output_ecdsa.txt
        cat account_create_output_ecdsa.txt
        JSON=$(cat account_create_output_ecdsa.txt | python3 $GITHUB_ACTION_PATH/extractAccountAsJson.py) || {
          echo "Error: Python script extractAccountAsJson.py failed"
          exit 1
        }
        export ACCOUNT_ID=$(echo $JSON | jq -r '.accountId')
        export ACCOUNT_PUBLIC_KEY=$(echo $JSON | jq -r '.publicKey')
        export ACCOUNT_PRIVATE_KEY=$(kubectl get secret account-key-$ACCOUNT_ID -n $SOLO_NAMESPACE -o jsonpath='{.data.privateKey}' | base64 -d | xargs)
        solo account update --account-id $ACCOUNT_ID --hbar-amount 10000000 --deployment $SOLO_DEPLOYMENT -n $SOLO_NAMESPACE
        echo "accountId=$ACCOUNT_ID"
        echo "publicKey=$ACCOUNT_PUBLIC_KEY"
        echo "privateKey=$ACCOUNT_PRIVATE_KEY"
        echo "accountId=$ACCOUNT_ID" >> $GITHUB_OUTPUT
        echo "publicKey=$ACCOUNT_PUBLIC_KEY" >> $GITHUB_OUTPUT
        echo "privateKey=$ACCOUNT_PRIVATE_KEY" >> $GITHUB_OUTPUT

    - name: Create ED25519 Account
      id: create-ed25519
      shell: bash
      env:
        GITHUB_ACTION_PATH: ${{ github.action_path }}
        SOLO_NAMESPACE: solo
        SOLO_DEPLOYMENT: solo-deployment
      run: |
        echo "Creating ED25519 account..."
        solo account create --deployment $SOLO_DEPLOYMENT -n $SOLO_NAMESPACE > account_create_output_ed25519.txt
        cat account_create_output_ed25519.txt
        JSON=$(cat account_create_output_ed25519.txt | python3 $GITHUB_ACTION_PATH/extractAccountAsJson.py) || {
          echo "Error: Python script extractAccountAsJson.py failed"
          exit 1
        }
        export ACCOUNT_ID=$(echo $JSON | jq -r '.accountId')
        export ACCOUNT_PUBLIC_KEY=$(echo $JSON | jq -r '.publicKey')
        export ACCOUNT_PRIVATE_KEY=$(kubectl get secret account-key-$ACCOUNT_ID -n $SOLO_NAMESPACE -o jsonpath='{.data.privateKey}' | base64 -d | xargs)
        solo account update --account-id $ACCOUNT_ID --hbar-amount 10000000 --deployment $SOLO_DEPLOYMENT -n $SOLO_NAMESPACE
        echo "accountId=$ACCOUNT_ID"
        echo "publicKey=$ACCOUNT_PUBLIC_KEY"
        echo "privateKey=$ACCOUNT_PRIVATE_KEY"
        echo "accountId=$ACCOUNT_ID" >> $GITHUB_OUTPUT
        echo "publicKey=$ACCOUNT_PUBLIC_KEY" >> $GITHUB_OUTPUT
        echo "privateKey=$ACCOUNT_PRIVATE_KEY" >> $GITHUB_OUTPUT

branding:
  icon: "share-2"
  color: "black"
